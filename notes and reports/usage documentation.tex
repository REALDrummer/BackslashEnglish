\documentclass{article}

\usepackage{indentfirst}		% indents the first line of paragraphs after (sub)*section headers
\usepackage[margin=1in]{geometry}	% makes 1in reasonable margins (as opposed to the huge default ones)
\usepackage{titlesec}			% allows the use of \paragraph and some other small section commands and tools
\usepackage[dvipsnames]{xcolor}	% allows the coloring of text, especially for the simulated syntax highlighting
\usepackage{lmodern}			% allows the use of lmodern fonts, which have less issues than the default like '<' doesn't become 'ยก' and tt text can be bold
\usepackage[T1]{fontenc}		% fixes those weird fint-compatibility issues that can turn '<' into 'ยก' and so forth
\usepackage[utf8x]{inputenc}		% allow the proper use and translation of Unicode characters

\setcounter{secnumdepth}{4}		% allows 4-point sequence numbers in delineating sections, e.g. "2.2.2.1"

\titleformat{\paragraph}
{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

\newcommand{\name}{\textbackslash{}English}				% just lets me avoid typing "\textbackslash{}English" all the time

% redefine headers for automatic labelling
\newcommand{\secl}[1]{\section{#1}\label{sec:#1}}
\newcommand{\ssecl}[1]{\subsection{#1}\label{ssec:#1}}
\newcommand{\sssecl}[1]{\subsubsection{#1}\label{sssec:#1}}

% commands for syntax highlighting code
\newcommand{\codecomment}[1]{\texttt{\textcolor{LimeGreen}{#1}}}
\newcommand{\commentline}[1]{\codecomment{\# #1}}
\newcommand{\type}[1]{\texttt{\textcolor{ForestGreen}{\textbf{#1}}}}
\newcommand{\keyop}[1]{\texttt{\textcolor{Purple}{\textbf{#1}}}}
\newcommand{\common}[1]{\texttt{\textcolor{Mulberry}{\textbf{#1}}}}
\newcommand{\defpunct}[1]{\texttt{\textcolor{SkyBlue}{\textbf{#1}}}}
\newcommand{\define}[2]{\texttt{\keyop{define} \defpunct{<}#1\defpunct{>} #2\defpunct{:}}}
\newcommand{\codestring}[1]{\texttt{\textcolor{NavyBlue}{"#1"}}}
\newcommand{\codechar}[1]{\texttt{\textcolor{Blue}{#1}}}
\newenvironment{code}[0]
{\ttfamily{}				% use true-type fonts for code
\setlength\parindent{0cm}	% remove paragraph indentation for code
~\\}
{\setlength\parindent{1cm}
~\\}

\begin{document}
\setlength\parindent{1cm}								% unify the paragraph indentation size

\tableofcontents
\newpage

\obeylines												% makes line breaks occur in the doducment as they occur in code

\secl{Introduction: What, Why, and How?}
\ssecl{What is \name{}?}

\ssecl{What makes it different?}

\ssecl{What is good about these differences?}

\ssecl{How are these differences possible?}

\secl{How to Use the Language}
\ssecl{Compilation}

\ssecl{First Things First}
\sssecl{\texttt{main(}... Oh, Wait}
\indent There is no main method/function/operator. Just write what you want to do!
\sssecl{Comments}
\indent I mention comments first because they'll be used in future examples within this documentation.
\indent The octothorpe ('\#') begins single-line comments:
\begin{code}
some code		\commentline{a comment}
\commentline{\#\#\#\#\# comment comment comment}
more code		\commentline{more comment with more \#s!}
\end{code}
\indent Octothorpes can be paired with angle brackets ('<' and '>') to make multi-line or inline comments:
\begin{code}
some \codecomment{\#< awesome >\#} code

\codecomment{\#\#\#< You can have as many \#s as you want and they don't
even have to match the number at the end! >\#\\}
code
\codecomment{\#< You can also have nested comments to make commenting out sections of code easier. 
I commented out the code below even though it also has multi-line comments.\\

\#< This is a comment >\# Here is some code that is commented and bad\\

Still, the comment doesn't end at the first ">" followed by an "\#"; it matches them like parentheses. 
>\#}
more code
\codecomment{\#\#< below is a pretty cool operator that we'll explain and even show you how to make later; this two-\# could be used as a doc comment (maybe?) >\#}
\define{\type{type of chars}}{string}
\qquad\type{chars}\defpunct{;}
\end{code}

\ssecl{Variables and Math}
\indent Math is important! \name{} has mutable variables like most languages and plenty of arithmatic operators for powerful math.

\sssecl{Declaring Variables}
\indent \name{} is strongly, statically typed. Variables need to be declared and need to be declared with a type. Variable declarations follow the same classic C-like format of a type followed by a name. Note that \name{} convention is the reverse of Java and many other languages: capitalize the first letter(s) of the variable names and keep types lowercase.

\begin{code}
\type{int} Integer
\type{queue} Queue
\end{code}

In \name{}, there's a bit of a twist: in this language, types, variable names, and other operators can have spaces, can be defined with special character-matching operators (as in operator definitions; see Section \ref{ssec:Operators} later on), and more. Here are some examples with spaces in the names of the variables and/or the names of their types:
\begin{code}
\type{int} Number of Variables
\type{list of queues of pairs of ints and floats} My Beautiful Queues
\end{code}

\sssecl{Assigning Variables}
\indent This is different from most languages! In \name{}, assign variables using "\texttt{:=}" rather than just "\texttt{=}". This leaves the "\texttt{=}" free for seeing if two things are equal (instead of "\texttt{==}").
\begin{code}
\type{int} Value := 5
\type{strings} Words := \codestring{blue}, \codestring{dog}, \common{and} \codestring{fishing} \commentline{More on this later in Section \ref{ssec:Lists and More}!}\\
\commentline{Yes, you can declare a variable without assigning it a value, then assign it later.}
\type{int} Seven	\commentline{Try and use it now and it will given you an error.}
Seven := 7	\commentline{Now it's safe because it has 7 in it.}
\end{code}

\sssecl{Numbers}
\indent This language can understand integers in base 10 normally; hexadecimal (base 16) with "\texttt{0x}"; octal (base 8) with "\texttt{0o}"; or binary (base 2) with "\texttt{0b}".
\begin{code}
\type{int} My Everyday Number := 839
\type{byte} A Byte := 0xFF
\type{int} Number of Legs on Ten Octopi := 0o100
\end{code}

\indent Oh, wait, little twist: base 10 numbers should have commas between every trio of digits just like in English! Numbers in other bases do not have commas.
\begin{code}
\type{int} Two Thousand One Seventeen := 2,117
\type{float} Five Million Fifteen Thousand Point One := 5,015,000.1
\end{code}

\indent In addition, it can understand not only base 10 floating point numbers, but also in the other bases mentioned! There aren't many places where that would be useful but\ldots{}eh.
\begin{code}
\type{float} Three And a Half := 3.5
\type{float} Three And a Half in Binary := 0b11.1
\type{float} Three And a Half in Hex := 0x3.8
\end{code}

\sssecl{Standard Number Types}
\indent \name{} includes a wide variety of different types of numbers; some have static memory sizes and some don't. Here are some of the most basic number types that do \emph{not} have set memory sizes:
\begin{itemize}
	\item \type{number} is any kind of number, floating point or integer, static or arbitrary size, etc.
	\item \type{decimal} is any kind of rational number, including integers, floating-point numbers, or any special kinds of numbers like integral fractions or square roots calculated lazily. All \type{decimal}s are types of \type{number}s.
	\item \type{integer} is any kind of integer or any size, arbitrary or static. All \type{integer}s are types of \type{decimal}s.
\end{itemize}

\indent \name{} also includes a few types of numbers of static size:
\begin{itemize}
	\item \type{bit} is a 1-bit integer. These are used instead of "bool"s or "boolean"s. Special note: \keyop{bits} is one of the very special pre-defined types; the \type{bit} type is just a special form of \keyop{bits} with one bit.
	\item \type{byte} is an 8-bit integer.
	\item \type{int} is a 32-bit integer.
	\item \type{float} is a 32-bit (single-precision) floating point number (IEEE-style).
\end{itemize}

\indent Other features of number types like the ability to ensure that a number is between two other numbers will be described in \ref{sssec:Type Modifiers}

\sssecl{Arithmetic}
\indent Most arithmetic is what you've seen a million times: there's "+", "-", "*", and "/". If either argument with any of these operators is floating-point, the result will be floating point, but if both are integers, then the result will be an integer (even the division).

\begin{code}
\type{integer} Eight := 5 + 3
\type{int} Four Over Two := 4 / 2
\type{decimal} Big Decimal := 2,100.0 * 15 \commentline{That first number is floating point even though its decimal portion is just a ".0", so this product is still floating point even though the second term is an integer.}
\type{integer} Integer Division := 3 / 2 \commentline{This is 1 because integer division!!}
\end{code}

\indent We've also got most all the rest of the C operator family: "\texttt{\%}" for modulus, "\texttt{++}" for increment (prefix or postfix), "\verb+--+" for decrement (prefix or postfix), "\verb+<<+" for bit shift left, "\verb+>>+" for bit shift right, and bitwise operators, too: "\texttt{\&}" for bitwise 'and', "\texttt{|}" for bitwise 'or', and "\texttt{\textasciitilde}" for bitwise negation.
\indent Note that C's "\texttt{\^}" bitwise 'xor' is missing; I'll reveal why in the next paragraph. You can use the mathematical xor symbol, though:

\begin{code}
\type{integer} One := 9 \% 4
\type{byte} Eight := 1 \verb+<<+ 3
\type{byte} Zero := 0b10010 \& 0b01001
\type{byte} All Ones := 0xF0 | 0o17
\type{byte} One Zero Zero One := \textasciitilde{}0b0110\\

\type{byte} i := 0
i++	\commentline{Now i is 1.}\\

\commentline{Here's now \name{} does xor:}
\type{byte} One One := 0b10 (+) 0b01 \commentline{It's meant to look like the xor circled plus, which you can also use.}\\

\commentline{Oh, yeah, and modulus works with floats as well as ints!}
\type{float} One Half := 3 \% 1.25	\commentline{Remember: one float means the result will be a float.}
\end{code}

\indent There are lots of custom arithmatic operators, too! Exponents are done with the "\texttt{\^}". (This is why the C-style bitwise 'xor' is not used.) In addition, there are cool symbolic operators for absolute value, ceiling, floor, and more.
\begin{code}
\type{integer} Twenty Seven := 3 \^{} 3
\type{float} Three Point Five := |-3.5|	\commentline{absolute value}
\type{int} Four := |\^{}3.5\^{}| \commentline{ceiling; meant to look like "โ3.5โ", which you can also use.}
\type{int} Three := |\_3.5\_| \commentline{floor; meant to look like "โ3.5โ", which you can also use.}
\end{code}

\indent Finally, just like C, those binary operators can be joined with the equals sign to make cool assignment-modifications operators:
\begin{code}
\type{int} Eight := 5	\commentline{Here, Eight equals 5.}
Eight += 3	\commentline{Now it's actually 8.}
\\
\type{byte} One := 9	\commentline{Now it's 9\ldots.}
One \%= 4	\commentline{Okay, now it's 1.}
\end{code}

\ssecl{Lists and More}
\indent Lists are difficult to use in most languages, but I honestly think that lists are easier to use in \name{} than in any other language!!
\indent First off, the top of the inheritance chain concerning grouping things is a "\type{collection}". This includes \type{lists}, \type{sets}, \type{stacks}, \type{trees}, \type{tuples}, and more. It includes pretty much anything that contains other things. The other (arguably) most important type in here is "\type{list}", which is anything that contains things that can be linearly ordered (indexed, i.e. numbered). The most notable \type{collection} that is not a \type{list} is a \type{set}.
\indent First cool thing: collections are the type that includes any grouping of one of more things, including lists, arrays, sets, and all the rest. How do you make them? Just use the plural of the type! By default, you just put an "s" at the end, like "\type{strings}"; however, some types (like "\type{process}") will have their own specially defined collection syntax with their proper plural ("\type{processes}"). If you make your own type, you can define its plural, too. You don't have to settle with using an "array of bushs"; no one wants that. One downside is that if you're working with words like "deer" that are the same in plural and singular forms, you'll have to write out "\type{collection of deer}", but the stdlib can help take care of that with the "\common{identically-plural}" modifier (more on modifiers in Section \ref{ssec:Op Modifiers}).
\indent The last cool thing you need to know before trying to make or use lists: list types consist of the type of list; the word "of"; and the plural (collection) of that type\ldots yeah, you guessed it, just like English. For example, an array of strings would be\ldots well, "\type{array of strings}"!

\sssecl{Making a List}
\indent The first thing you need to know about how to make a list is how to make an array. Do it like English! Comma-delimit the items and use an 'and' near the end for three or more; use just an 'and' for two items; and single items can just be used as one-item lists as they are (more on that in Section \ref{ssec:Implicit Conversion}).
\begin{code}
\type{strings} Words := \codestring{blue}, \codestring{dog}, \common{and} \codestring{fishing} \commentline{You saw this earlier.}
\type{array of ints} Numbers := 0o8823 \common{and} 6,598
\type{bytes} Bytes := 0xCD \commentline{Yep, this is fine. One byte ==> an array of bytes containing one byte.}
\end{code}

\indent For other kinds of lists, you can just use "a new"; the type of the list; and optionally the word "with" followed by the items you want to put into the new list initially. Of course, if you leave out the optional "with\ldots" part, you'll get an empty list. Some types of lists may require additional information; for example, a sorted list has to know how to sort the list, but we'll get to that when we get to high-order functionality in Section \ref{ssec:High Order Functionality}.
\begin{code}
\commentline{This kind of list has no declared element type, so will take anything: numbers, strings, custom objects, whatever!}
\type{list} Empty List := \common{a new} \type{array}

\commentline{Remember: "strings" means "collection of strings" and sets are collections, too!}
\type{strings} Words := \common{a new} \type{set of strings} \common{with} \codestring{blue}, \codestring{dog}, \common{and} \codestring{fishing}
\end{code}

\sssecl{List Arithmetic}
\indent Lists can be changed and manipulated. Of course they can! But how? Well, here are some examples below. First, here are the basics:
\begin{code}
\type{ints} Odd Numbers := 1, 3, 5, \common{and} 7
\type{ints} Even Numbers := 2, 4, 6, \common{and} 8
Odd Numbers's size \commentline{4 because Odd Numbers has 4 elements}
Odd Numbers + Even Numbers \commentline{1, 3, 5, 7, 2, 4, 6, and 8; concatenation}
Odd Numbers + 9 \commentline{1, 3, 5, 7, and 9; 9 becomes a list with a single item implicitly}
Odd Numbers = Even Numbers \commentline{false; it sees if all the elements in each collection are equivalent (and in the same order for lists)}
3 \common{is in} Odd Numbers \commentline{true because 3 is in Odd Numbers}
2, 4, \common{and} 5 \common{are in} Even Numbers \commentline{false because 5 isn't in Even Numbers}
\commentline{Yes, you can use those += and similar operators, too.}
\end{code}

\indent Yeah, plus is common enough for a concatenation operator, but with \name{}, we have more cool list arithmatic operators:
\begin{code}
\type{ints} Paired Odd Numbers := 1, 1, 3, 3, \common{and} 5
\type{ints} Prime Numbers := 2, 3, 5, 7, \common{and} 11
Paired Odd Numbers - Prime Numbers \commentline{1, 1, and 3; subtraction removes the FIRST matching element in the first collection for each element in the second}
Paired Odd Numbers \% Prime Numbers \commentline{1 and 1; modulus removes EVERY element in the first collection that matches one in the second}
Prime Numbers * 2 \commentline{2, 3, 5, 7, 2, 3, 5, and 7; a list times a number is that list repeated that many times!}

\commentline{There are currently no uses for multiplying a list by a list or dividing a list by something.}
\end{code}

\indent Those are the arithmatic ones that utilize the mathematical symbols, but there are other list utilities, too (many inspired by Haskell):
\begin{code}
\commentline{Going back to these guys again\ldots}
\common{zip} Odd Numbers \common{and} Even Numbers \commentline{1, 2, 3, 4, 5, 6, 7, and 8; it takes an element from each list one at a time}
Odd Numbers \common{starts with} 1, 3, \common{and} 5 \commentline{true}
4's \common{index in} Even Numbers \commentline{1 because Even Numbers[1] is 4 (indexed from 0; see Section \ref{sssec:List Indexes})}
7's \common{last index in} Odd Numbers \commentline{3 because Odd Numbers[3] is 11}
\end{code}

\indent There are so many more cool ones\ldots but I'm afraid that they'll have to wait until Section \ref{ssec:High Order Functionality} on high-order functionality.

\sssecl{List Indexes}
\indent Accessing list items by index is done with the classic "box notation" (with "\texttt{[]}"s) from index 0.
\begin{code}
\type{array of ints} Integers := 15 \common{and} 27
Integers[0]	\commentline{15}
Integers[2] \commentline{ERROR!}
Integers[0] := 26	\commentline{Integers now has 26 and 27}
Integers[0]++	\commentline{Integers now has two 27s}
\end{code}

\indent Accessing with this box notation will be available for any type of \type{list}, including not just \type{arrays}, but also \type{linked lists}, \type{binary trees}, \type{queues} and more! \emph{However}, only in lists will you be able to modify things with that box notation!
\begin{code}
\type{strings} Words := \codestring{blue}, \codestring{dog}, \common{and} \codestring{fishing} \commentline{This list again?!}
Words[2] \commentline{"fishing"}
Words[0] := \codestring{cat} \commentline{ERROR! Look: Words is declared as "strings", not a "list of strings"!}
\end{code}

\indent Here's a convenient twist: negative numbers index from the end of a list. You might think about it like if you get a negative number, it will add the size of the list to it and use that as the index. It makes things pretty convenient for messing with the end of a list.
\begin{code}
\type{list of ints} Count := 0, 1, 2, 3, 4, 5, 6, 7, \common{and} 8
Count[-2] \commentline{7!; Count's size - 2 = 9 - 2 = 7}
\end{code}

\indent It gets better, though. You can get segments of lists through box notation with the easy use of a couple words: "\common{to}" and "\common{from}". Observe:
\begin{code}
\commentline{I'll use the same "Count" as in the last example.}
Count[4 \common{to} 8] \commentline{4, 5, 6, and 7; note that the first index is inclusive and the second is exclusive.}
Count[\common{to} 3] \commentline{0, 1, and 2; when the first index is omitted, it's considered 0.}
Count[\common{from} -2] \commentline{7 and 8; yes, you can use negative indices here, too.}
\end{code}

\indent Even more: you can use any kind of list of unsigned integers as indices and it will put it together for you! Combine this stuff with the array list syntax!
\begin{code}
\commentline{I'm going to use the same "Count" from the last example.}
Count[0, 5, \common{and} 2] \commentline{0, 5, and 2}
Count[\common{to} 4, 6, \common{and from} -1] \commentline{0, 1, 2, 3, 6, and 8}
Count[0, 5, 1, 0, \common{and from} 5] \commentline{0, 5, 1, 0, 5, 6, 7, and 8; yes, repetition is allowed}
\end{code}

\indent I think the \type{string} examples below are more fun.

\sssecl{Strings Are Lists And More!}
\indent All the stuff you've seen about \type{lists} and \type{collections} so far applies to \type{strings} too\ldots because what are \type{strings} but \type{lists of chars}? Of course, as you've seen earlier and I didn't mention because it's kind of obvious, you can delimit strings with double quotes, e.g. \codestring{dog}. In addition, like in C-like languages, \type{chars} can be given by single quotes, e.g. \codechar{'A'}.
\begin{code}
\type{list of chars} Word := \codestring{house} \commentline{Yep! All good here.}
Word[3]	\commentline{'s'; you could do this even if Word was declared as "string".}
Word[0] := \codechar{'m'} \commentline{Word is now "mouse".}
Word[\common{from} 2] \commentline{"use"}\\

\type{string} City := \codestring{New York City}
City[4 \common{to} 8] \commentline{"York"}
City[\common{to} 8] \commentline{"New York"}
City[\common{from} 10] \commentline{"City"}
City[4 \common{to} -5] \commentline{"York"}
City[\common{to} 5] * 3 + City[\common{from} 5] \commentline{"New New New York City"}
\end{code}

TODO: more to add here!

\indent Note that \name{} \type{strings} aren't generally null-terminated like in C. If you're using C stuff, be careful about that.

\sssecl{Special List Types}
\indent Here's an incredibly powerful tool that you won't find in almost any other programming language: you can specify the size of the list as part of the type! As we'll explain more later on in Section \ref{ssec:Types}, types can come with any kinds of properties: not just other types like Java or C++, but numbers, strings, or whatever else you can think of!
\begin{code}
3 \type{strings} Three Words For You := \codestring{I}, \codestring{hate}, and \codestring{you}	\commentline{"I", "hate", and "you"}
Three Words For You[1] := \codestring{love}	\commentline{"I", "love", and "you"}
Three Words For You := \codestring{I} and \codestring{love}	\commentline{ERROR! There are only two strings in this array!}
\end{code}

\indent There are a million uses for that one.
\indent There are times when you want to make a data structure with lots of dimensions, e.g. a four-dimensional matrix (for all you crazy math people out there)\ldots{}but who would want to write out "\type{list of lists of lists of lists of numbers}"? Thankfully, you don't have to!
\begin{code}
4-D \type{list of numbers} Hyperdimensional List := \common{a new} 4-D \type{list of numbers}
Hyperdimensional Matrix += 0	\commentline{[[[[0]]]]}
Hyperdimensional Matrix += (0, 5, and 9) and 12	\commentline{[[[[0], [0, 5, 9], [12]]]]}
\end{code}

\indent TODO: "sorted" lists

\sssecl{Streaming (not the Netflix kind)}

\ssecl{Code Blocks}
\sssecl{If and Its Friends}

\sssecl{Loops}

\ssecl{Operators}
\paragraph{Defining Them}

\paragraph{Using Them}

\ssecl{Op Modifiers}
\sssecl{Definining Them}
\paragraph{Using Them}
\ssecl{Types}
\paragraph{Defining Them}

\paragraph{Using Them}

\sssecl{Type Modifiers}
\paragraph{Defining Them}

\paragraph{Using Them}

\sssecl{Units}
\paragraph{Defining Them}

\paragraph{Using Them}

\ssecl{Errors}
\paragraph{Defining Them}

\paragraph{Using Them}

\ssecl{Input and Output}
\sssecl{Stdin Reading and Stdout Printing}

\sssecl{File Reading and Writing}

\ssecl{Implicit Conversion}
\sssecl{What?}

\sssecl{Why?}

\sssecl{Super-implicit?}

\ssecl{High Order Functionality}
\sssecl{What?}

\sssecl{Why?}

\sssecl{Missing Something? Partially Applied Operators}

\sssecl{Operator Modifiers}

\sssecl{Scope and Contextual Operators}

\secl{The Basis of the Language}
\ssecl{\texttt{\textbf{operator}}}

\ssecl{\texttt{\textbf{define}}}

\ssecl{\texttt{\textbf{asm}}}

\ssecl{\texttt{\textbf{run}}}

\ssecl{\texttt{\textbf{bits}}}

\ssecl{\texttt{\textbf{use}}}

\secl{The Not-So-Complicated Compilation}
\ssecl{Idea}

\ssecl{Optimizability}
\end{document}
