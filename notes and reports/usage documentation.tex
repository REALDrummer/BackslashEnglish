\documentclass{article}

\usepackage{indentfirst}		% indents the first line of paragraphs after (sub)*section headers
\usepackage[margin=1in]{geometry}	% makes 1in reasonable margins (as opposed to the huge default ones)
\usepackage{titlesec}			% allows the use of \paragraph and some other small section commands and tools
\usepackage[dvipsnames]{xcolor}	% allows the coloring of text, especially for the simulated syntax highlighting
\usepackage{lmodern}			% allows the use of lmodern fonts, which have less issues than the default like '<' doesn't become 'ยก' and tt text can be bold
\usepackage[T1]{fontenc}		% fixes those weird fint-compatibility issues that can turn '<' into 'ยก' and so forth
\usepackage[utf8x]{inputenc}		% allow the proper use and translation of Unicode characters

\setcounter{secnumdepth}{4}		% allows 4-point sequence numbers in delineating sections, e.g. "2.2.2.1"

\titleformat{\paragraph}
{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

\newcommand{\English}{\textbackslash{}English}				% just lets me avoid typing "\textbackslash{}English" all the time

% redefine headers for automatic labelling
\newcommand{\secl}[1]{\section{#1}\label{sec:#1}}
\newcommand{\ssecl}[1]{\subsection{#1}\label{ssec:#1}}
\newcommand{\sssecl}[1]{\subsubsection{#1}\label{sssec:#1}}

% commands for syntax highlighting code
\newcommand{\codecomment}[1]{\texttt{\textcolor{LimeGreen}{#1}}}
\newcommand{\commentline}[1]{\codecomment{\# #1}}
\newcommand{\type}[1]{\texttt{\textcolor{ForestGreen}{\textbf{#1}}}}
\newcommand{\keyop}[1]{\texttt{\textcolor{Purple}{\textbf{#1}}}}
\newcommand{\common}[1]{\texttt{\textcolor{Mulberry}{\textbf{#1}}}}
\newcommand{\defpunct}[1]{\texttt{\textcolor{SkyBlue}{\textbf{#1}}}}
\newcommand{\preprocess}[1]{\texttt{\textcolor{CarnationPink}{#1}}}
\newcommand{\define}[2]{\texttt{\keyop{define} \defpunct{<}#1\defpunct{>} #2\defpunct{:}}}
\newcommand{\codestring}[1]{\texttt{\textcolor{NavyBlue}{"#1"}}}
\newcommand{\codechar}[1]{\texttt{\textcolor{Blue}{#1}}}
\newenvironment{code}[0]
{\ttfamily{}				% use true-type fonts for code
\setlength\parindent{0cm}	% remove paragraph indentation for code
~\\}
{\setlength\parindent{1cm}
~\\}

\begin{document}
\setlength\parindent{1cm}								% unify the paragraph indentation size

\tableofcontents
\newpage

\obeylines												% makes line breaks occur in the doducment as they occur in code

\secl{Introduction: What, Why, and How?}
\ssecl{What is \English{}?}

\ssecl{What makes it different?}

\ssecl{What is good about these differences?}

\ssecl{How are these differences possible?}

\secl{How to Use the Language}
\ssecl{Compilation}

\ssecl{First Things First}
\sssecl{\texttt{main(}... Oh, Wait}
\indent There is no main method/function/operator. Just write what you want to do!
\sssecl{Comments}
\indent I mention comments first because they'll be used in future examples within this documentation.
\indent The octothorpe ('\#') begins single-line comments:
\begin{code}
some code		\commentline{a comment}
\commentline{\#\#\#\#\# comment comment comment}
more code		\commentline{more comment with more \#s!}
\end{code}
\indent Octothorpes can be paired with angle brackets ('<' and '>') to make multi-line or inline comments:
\begin{code}
some \codecomment{\#< awesome >\#} code

\codecomment{\#\#\#< You can have as many \#s as you want and they don't
even have to match the number at the end! >\#\\}
code
\codecomment{\#< You can also have nested comments to make commenting out sections of code easier. 
I commented out the code below even though it also has multi-line comments.\\

\#< This is a comment >\# Here is some code that is commented and bad\\

Still, the comment doesn't end at the first ">" followed by an "\#"; it matches them like parentheses. 
>\#}
more code
\codecomment{\#\#< below is a pretty cool operator that we'll explain and even show you how to make later; this two-\# could be used as a doc comment (maybe?) >\#}
\define{\type{type of chars}}{string}
\qquad\type{chars}\defpunct{;}
\end{code}

\ssecl{Variables and Math}
\indent Math is important! \English{} has mutable variables like most languages and plenty of arithmatic operators for powerful math.

\sssecl{Declaring Variables}
\indent \English{} is strongly, statically typed. Variables need to be declared and need to be declared with a type. Variable declarations follow the same classic C-like format of a type followed by a name. Note that \English{} convention is the reverse of Java and many other languages: capitalize the first letter(s) of the variable names and keep types lowercase.

\begin{code}
\type{int} Integer
\type{queue} Queue
\end{code}

In \English{}, there's a bit of a twist: in this language, types, variable names, and other operators can have spaces, can be defined with special character-matching operators (as in operator definitions; see Section \ref{ssec:Operators} later on), and more. Here are some examples with spaces in the names of the variables and/or the names of their types:
\begin{code}
\type{int} Number of Variables
\type{list of queues of pairs of ints and floats} My Beautiful Queues
\end{code}

\sssecl{Assigning Variables}
\indent This is different from most languages! In \English{}, assign variables using "\texttt{:=}" rather than just "\texttt{=}". This leaves the "\texttt{=}" free for seeing if two things are equal (instead of "\texttt{==}").
\begin{code}
\type{int} Value := 5
\type{strings} Words := \codestring{blue}, \codestring{dog}, \common{and} \codestring{fishing} \commentline{More on this later in Section \ref{ssec:Lists and More}!}\\
\commentline{Yes, you can declare a variable without assigning it a value, then assign it later.}
\type{int} Seven	\commentline{Try and use it now and it will given you an error.}
Seven := 7	\commentline{Now it's safe because it has 7 in it.}
\end{code}

\sssecl{Numbers}
\indent This language can understand integers in base 10 normally; hexadecimal (base 16) with "\texttt{0x}"; octal (base 8) with "\texttt{0o}"; or binary (base 2) with "\texttt{0b}".
\begin{code}
\type{int} My Everyday Number := 839
\type{byte} A Byte := 0xFF
\type{int} Number of Legs on Ten Octopi := 0o100
\end{code}

\indent Oh, wait, little twist: base 10 numbers should have commas between every trio of digits just like in English! Numbers in other bases do not have commas.
\begin{code}
\type{int} Two Thousand One Seventeen := 2,117
\type{float} Five Million Fifteen Thousand Point One := 5,015,000.1
\end{code}

\indent In addition, it can understand not only base 10 floating point numbers, but also in the other bases mentioned! There aren't many places where that would be useful but\ldots{}eh.
\begin{code}
\type{float} Three And a Half := 3.5
\type{float} Three And a Half in Binary := 0b11.1
\type{float} Three And a Half in Hex := 0x3.8
\end{code}

\sssecl{Standard Number Types}
\indent \English{} includes a wide variety of different types of numbers; some have static memory sizes and some don't. Here are some of the most basic number types that do \emph{not} have set memory sizes:
\begin{itemize}
	\item \type{number} is any kind of number, floating point or integer, static or arbitrary size, etc.
	\item \type{decimal} is any kind of rational number, including integers, floating-point numbers, or any special kinds of numbers like integral fractions or square roots calculated lazily. All \type{decimal}s are types of \type{number}s.
	\item \type{integer} is any kind of integer or any size, arbitrary or static. All \type{integer}s are types of \type{decimal}s.
\end{itemize}

\indent \English{} also includes a few types of numbers of static size:
\begin{itemize}
	\item \type{bit} is a 1-bit integer. These are used instead of "bool"s or "boolean"s. Special note: \keyop{bits} is one of the very special pre-defined types; the \type{bit} type is just a special form of \keyop{bits} with one bit.
	\item \type{byte} is an 8-bit integer.
	\item \type{int} is a 32-bit integer.
	\item \type{float} is a 32-bit (single-precision) floating point number (IEEE-style).
\end{itemize}

\indent Other features of number types like the ability to ensure that a number is between two other numbers will be described in \ref{sssec:Type Modifiers}

\sssecl{Arithmetic}
\indent Most arithmetic is what you've seen a million times: there's "+", "-", "*", and "/". If either argument with any of these operators is floating-point, the result will be floating point, but if both are integers, then the result will be an integer (even the division).

\begin{code}
\type{integer} Eight := 5 + 3
\type{int} Four Over Two := 4 / 2
\type{decimal} Big Decimal := 2,100.0 * 15 \commentline{That first number is floating point even though its decimal portion is just a ".0", so this product is still floating point even though the second term is an integer.}
\type{integer} Integer Division := 3 / 2 \commentline{This is 1 because integer division!!}
\end{code}

\indent We've also got most all the rest of the C operator family: "\texttt{\%}" for modulus, "\texttt{++}" for increment (prefix or postfix), "\verb+--+" for decrement (prefix or postfix), "\verb+<<+" for bit shift left, "\verb+>>+" for bit shift right, and bitwise operators, too: "\texttt{\&}" for bitwise 'and', "\texttt{|}" for bitwise 'or', and "\texttt{\textasciitilde}" for bitwise negation.
\indent Note that C's "\texttt{\^}" bitwise 'xor' is missing; I'll reveal why in the next paragraph. You can use the mathematical xor symbol, though:

\begin{code}
\type{integer} One := 9 \% 4
\type{byte} Eight := 1 \verb+<<+ 3
\type{byte} Zero := 0b10010 \& 0b01001
\type{byte} All Ones := 0xF0 | 0o17
\type{byte} One Zero Zero One := \textasciitilde{}0b0110\\

\type{byte} i := 0
i++	\commentline{Now i is 1.}\\

\commentline{Here's now \English{} does xor:}
\type{byte} One One := 0b10 (+) 0b01 \commentline{It's meant to look like the xor circled plus symbol, which you can also use.}\\

\commentline{Oh, yeah, and modulus works with floats as well as ints!}
\type{float} One Half := 3 \% 1.25	\commentline{Remember: one float means the result will be a float.}
\end{code}

\indent There are lots of custom arithmatic operators, too! Exponents are done with the "\texttt{\^}". (This is why the C-style bitwise 'xor' is not used.) In addition, there are cool symbolic operators for absolute value, ceiling, floor, and more.
\begin{code}
\type{integer} Twenty Seven := 3 \^{} 3
\type{float} Three Point Five := |-3.5|	\commentline{absolute value}
\type{int} Four := |\^{}3.5\^{}| \commentline{ceiling; meant to look like "โ3.5โ", which you can also use.}
\type{int} Three := |\_3.5\_| \commentline{floor; meant to look like "โ3.5โ", which you can also use.}
\end{code}

\indent Finally, just like C, those binary operators can be joined with the equals sign to make cool assignment-modifications operators:
\begin{code}
\type{int} Eight := 5	\commentline{Here, Eight equals 5.}
Eight += 3	\commentline{Now it's actually 8.}
\\
\type{byte} One := 9	\commentline{Now it's 9\ldots.}
One \%= 4	\commentline{Okay, now it's 1.}
\end{code}

\sssecl{Comparisons}
\indent Numbers can be compared in most of the usual ways. The first most notable part is that to see if two numbers are equal, we use "\texttt{=}" rather than "\texttt{==}" like you'd see in most languages. Other than that, things look mostly the same: "\texttt{<}" sees if the first thing is less than the second thing, "\texttt{>}" does the opposite; "\texttt{<=}" sees if the first thing is less than or equal to the second thing, "\texttt{>=}" does the opposite; and "\texttt{!=}" sees if two things are not equal. Finally, one last one that you may or may not have sees in other languages: "\texttt{<=>}" "compares" the two values given to it; it returns a 2-bit number that is 0 if the first number is less than the second, 1 if they are equal, and 2 if the first number is greater than the second. Note that these same comparison operators can be used for things other than numbers! However, since we're talking about numbers right now, we'll stick with number examples.
\indent All comparisons return a \type{bit}, a 1-bit number that is either 1 or 0. 1 means "\common{true}"; 0 means "\common{false}". Since \type{bit} is still a type of number, you can also use it as one, but this generally makes things less readable, so I'd advise against it.
\begin{code}
\commentline{Again, you can do the operations below, but they're not that readable, so please try to avoid it.}
\type{bit} True := 5 >= 3
\type{bit} False := 7 != 7
\type{bit} True := 9 * 7 < 8 * 8 \% 100\\
2-bit \type{number} Two For Greater Than := 7 * 2 <=> 3^2

\commentline{Here is a more common use of these comparison operators that will be explained more in Section \ref{sssec:If And Its Friends}.}
\common{if} Number != 8,
	Number := 8
\end{code}

\ssecl{Bit/Boolean Logic}
\indent Remember how in Section \ref{ssec:Variables and Math}, we mentioned that \English{} has 1-bit numbers? This is how we represent what other languages might call "booleans" or "bools". Boolean values are "true" or "false"; bit values are "1" or "0". Why not just combine the concepts? \English{} does; 1 is true and 0 is false (kind of like in C, except that other numbers like 5 and -19 aren't true or false or even bits at all)!
\begin{code}
\type{bit} Kittens Are Cute := 1 \commentline{This acts like "true".}
\type{bit} 9 Is a Letter := \common{false} \commentline{"true" and "false" mean the same as "1" and "0", respectively.}
\type{bit} Your Computer := \common{on} \commentline{Also, "on" = "true" and "off" = "false"!}
\type{bit} I Like Dogs := \common{yes} \commentline{"yes" also means "true" and "no" also means "false"! So many choices!}
\end{code}

\indent Like in English, and like in Python, to compare and perform logic on booleans (bits), you can use the English words "and", "or", "xor", and "not".
\begin{code}
\commentline{I will use the same bit variables I made above.}
\type{bit} False := Kittens Are Cute \common{and} 9 Is a Letter
\type{bit} No := 9 Is a Letter \common{or} 5 < 3
\type{bit} Quotient Is Negative := Dividend < 0 \common{xor} Divisor < 0
\type{bit} Yes := \common{not} No
\end{code}

\indent Uh\ldots short section!

\ssecl{Lists and More}
\indent Lists are difficult to use in most languages, but I honestly think that lists are easier to use in \English{} than in any other language!!
\indent First off, the top of the inheritance chain concerning grouping things is a "\type{collection}". This includes \type{lists}, \type{sets}, \type{stacks}, \type{trees}, \type{tuples}, and more. It includes pretty much anything that contains other things. The other (arguably) most important type in here is "\type{list}", which is anything that contains things that can be linearly ordered (indexed, i.e. numbered). The most notable \type{collection} that is not a \type{list} is a \type{set}.
\indent First cool thing: collections are the type that includes any grouping of one of more things, including lists, arrays, sets, and all the rest. How do you make them? Just use the plural of the type! By default, you just put an "s" at the end, like "\type{strings}"; however, some types (like "\type{process}") will have their own specially defined collection syntax with their proper plural ("\type{processes}"). If you make your own type, you can define its plural, too. You don't have to settle with using an "array of bushs"; no one wants that. One downside is that if you're working with words like "deer" that are the same in plural and singular forms, you'll have to write out "\type{collection of deer}", but the stdlib can help take care of that with the "\common{identically-plural}" modifier (more on modifiers in Section \ref{ssec:Op Modifiers}).
\indent The last cool thing you need to know before trying to make or use lists: list types consist of the type of list; the word "of"; and the plural (collection) of that type\ldots yeah, you guessed it, just like English. For example, an array of strings would be\ldots well, "\type{array of strings}"!

\sssecl{Making a List}
\indent The first thing you need to know about how to make a list is how to make an array. Do it like English! Comma-delimit the items and use an 'and' near the end for three or more; use just an 'and' for two items; and single items can just be used as one-item lists as they are (more on that in Section \ref{ssec:Implicit Conversion}).
\begin{code}
\type{strings} Words := \codestring{blue}, \codestring{dog}, \common{and} \codestring{fishing} \commentline{You saw this earlier.}
\type{array of ints} Numbers := 0o8823 \common{and} 6,598
\type{bytes} Bytes := 0xCD \commentline{Yep, this is fine. One byte ==> an array of bytes containing one byte.}
\end{code}

\indent For other kinds of lists, you can just use "a new"; the type of the list; and optionally the word "with" followed by the items you want to put into the new list initially. Of course, if you leave out the optional "with\ldots" part, you'll get an empty list. Some types of lists may require additional information; for example, a sorted list has to know how to sort the list, but we'll get to that when we get to high-order functionality in Section \ref{ssec:High Order Functionality}.
\begin{code}
\commentline{This kind of list has no declared element type, so will take anything: numbers, strings, custom objects, whatever!}
\type{list} Empty List := \common{a new} \type{array}

\commentline{Remember: "strings" means "collection of strings" and sets are collections, too!}
\type{strings} Words := \common{a new} \type{set of strings} \common{with} \codestring{blue}, \codestring{dog}, \common{and} \codestring{fishing}
\end{code}

\sssecl{List Arithmetic}
\indent Lists can be changed and manipulated. Of course they can! But how? Well, here are some examples below. First, here are the basics:
\begin{code}
\type{ints} Odd Numbers := 1, 3, 5, \common{and} 7
\type{ints} Even Numbers := 2, 4, 6, \common{and} 8
Odd Numbers's size \commentline{4 because Odd Numbers has 4 elements}
Odd Numbers + Even Numbers \commentline{1, 3, 5, 7, 2, 4, 6, and 8; concatenation}
Odd Numbers + 9 \commentline{1, 3, 5, 7, and 9; 9 becomes a list with a single item implicitly}
Odd Numbers = Even Numbers \commentline{false; it sees if all the elements in each collection are equivalent (and in the same order for lists)}
3 \common{is in} Odd Numbers \commentline{true because 3 is in Odd Numbers}
2, 4, \common{and} 5 \common{are in} Even Numbers \commentline{false because 5 isn't in Even Numbers}
\commentline{Yes, you can use those += and similar operators, too.}
\end{code}

\indent Yeah, plus is common enough for a concatenation operator, but with \English{}, we have more cool list arithmatic operators:
\begin{code}
\type{ints} Paired Odd Numbers := 1, 1, 3, 3, \common{and} 5
\type{ints} Prime Numbers := 2, 3, 5, 7, \common{and} 11
Paired Odd Numbers - Prime Numbers \commentline{1, 1, and 3; subtraction removes the FIRST matching element in the first collection for each element in the second}
Paired Odd Numbers \% Prime Numbers \commentline{1 and 1; modulus removes EVERY element in the first collection that matches one in the second}
Prime Numbers * 2 \commentline{2, 3, 5, 7, 2, 3, 5, and 7; a list times a number is that list repeated that many times!}

\commentline{There are currently no uses for multiplying a list by a list or dividing a list by something.}
\end{code}

\indent Those are the arithmatic ones that utilize the mathematical symbols, but there are other list utilities, too (many inspired by Haskell):
\begin{code}
\commentline{Going back to these guys again\ldots}
\common{zip} Odd Numbers \common{and} Even Numbers \commentline{1, 2, 3, 4, 5, 6, 7, and 8; it takes an element from each list one at a time}
Odd Numbers \common{starts with} 1, 3, \common{and} 5 \commentline{true}
4's \common{index in} Even Numbers \commentline{1 because Even Numbers[1] is 4 (indexed from 0; see Section \ref{sssec:List Indexes})}
7's \common{last index in} Odd Numbers \commentline{3 because Odd Numbers[3] is 11}
\end{code}

\indent There are so many more cool ones\ldots but I'm afraid that they'll have to wait until Section \ref{ssec:High Order Functionality} on high-order functionality.

\sssecl{List Indexes}
\indent Accessing list items by index is done with the classic "box notation" (with "\texttt{[]}"s) from index 0.
\begin{code}
\type{array of ints} Integers := 15 \common{and} 27
Integers[0]	\commentline{15}
Integers[2] \commentline{ERROR!}
Integers[0] := 26	\commentline{Integers now has 26 and 27}
Integers[0]++	\commentline{Integers now has two 27s}
\end{code}

\indent Accessing with this box notation will be available for any type of \type{list}, including not just \type{arrays}, but also \type{linked lists}, \type{binary trees}, \type{queues} and more! \emph{However}, only in lists will you be able to modify things with that box notation!
\begin{code}
\type{strings} Words := \codestring{blue}, \codestring{dog}, \common{and} \codestring{fishing} \commentline{This list again?!}
Words[2] \commentline{"fishing"}
Words[0] := \codestring{cat} \commentline{ERROR! Look: Words is declared as "strings", not a "list of strings"!}
\end{code}

\indent Here's a convenient twist: negative numbers index from the end of a list. You might think about it like if you get a negative number, it will add the size of the list to it and use that as the index. It makes things pretty convenient for messing with the end of a list.
\begin{code}
\type{list of ints} Count := 0, 1, 2, 3, 4, 5, 6, 7, \common{and} 8
Count[-2] \commentline{7!; Count's size - 2 = 9 - 2 = 7}
\end{code}

\indent It gets better, though. You can get segments of lists through box notation with the easy use of a couple words: "\common{to}" and "\common{from}". Observe:
\begin{code}
\commentline{I'll use the same "Count" as in the last example.}
Count[4 \common{to} 8] \commentline{4, 5, 6, and 7; note that the first index is inclusive and the second is exclusive.}
Count[\common{to} 3] \commentline{0, 1, and 2; when the first index is omitted, it's considered 0.}
Count[\common{from} -2] \commentline{7 and 8; yes, you can use negative indices here, too.}
\end{code}

\indent Even more: you can use any kind of list of unsigned integers as indices and it will put it together for you! Combine this stuff with the array list syntax!
\begin{code}
\commentline{I'm going to use the same "Count" from the last example.}
Count[0, 5, \common{and} 2] \commentline{0, 5, and 2}
Count[\common{to} 4, 6, \common{and from} -1] \commentline{0, 1, 2, 3, 6, and 8}
Count[0, 5, 1, 0, \common{and from} 5] \commentline{0, 5, 1, 0, 5, 6, 7, and 8; yes, repetition is allowed}
\end{code}

\indent I think the \type{string} examples below are more fun.

\sssecl{Comparing Lists}
\indent Remember all those numerical comparison operators from Section \ref{sssec:Comparisons}? Well, you can use those for lists, too! They work like you would expect.
\indent The equality operators ("\texttt{=}" and "\texttt{!=}") first see whether or not the sizes of the lists and each element in each of the lists are equal.
\indent The five inequality operators ("\texttt{<}", "\texttt{>}", "\texttt{<=}", "\texttt{>=}", and "\texttt{<=>}") go through each list element one at a time from the beginning of the two lists being compared until they find a difference, then return the result of that operation on the first difference. If they reach the end of one list and the lists are different sizes, then they return the result of that operation on the sizes of the two lists. Note that all the things in the two lists must be comparable for these operations to work!
\begin{code}
\type{bit} True := (5, 3, \common{and} 4) < (5, 6, \common{and} 2) \commentline{Yes, 4 > 2 at the end, but 3 < 6 before that.}
\type{bit} False := (\codestring{Drake} \common{and} \codestring{Josh}) = (\codestring{Drake}, \codestring{Josh}, \common{and} \codestring{Megan})
\commentline{ERROR below because how would you compare cars? If you define an operator to compare cars, then this would work, but I don't even know how you would objectively compare cars\ldots{}.}
\commentline{Also remember that that first car will be implicitly converted to a list with one element.}
\type{bit} What := 1990 Buick LeSabre < (1959 Ford Mustang \common{and} 1966 Dodge Charger)
\commentline{Oh, and this is great: strings are just lists of chars, so use these for string lexicographic comparison, too!}
\type{bit} False := \codestring{apple} <= \codestring{aardvark}
\end{code}

\sssecl{Strings Are Lists And More!}
\indent All the stuff you've seen about \type{lists} and \type{collections} so far applies to \type{strings} too\ldots because what are \type{strings} but \type{lists of chars}? Of course, as you've seen earlier and I didn't mention because it's kind of obvious, you can delimit strings with double quotes, e.g. \codestring{dog}. In addition, like in C-like languages, \type{chars} can be given by single quotes, e.g. \codechar{'A'}.
\begin{code}
\type{list of chars} Word := \codestring{house} \commentline{Yep! All good here.}
Word[3]	\commentline{'s'; you could do this even if Word was declared as "string".}
Word[0] := \codechar{'m'} \commentline{Word is now "mouse".}
Word[\common{from} 2] \commentline{"use"}\\

\type{string} City := \codestring{New York City}
City[4 \common{to} 8] \commentline{"York"}
City[\common{to} 8] \commentline{"New York"}
City[\common{from} 10] \commentline{"City"}
City[4 \common{to} -5] \commentline{"York"}
City[\common{to} 5] * 3 + City[\common{from} 5] \commentline{"New New New York City"}

\type{bit} True := City \common{starts with} \codestring{New }
\end{code}

\indent Yes, yes, strings could use some operators unbefitting of other lists. We have a bunch of those, too. The coolest ones are the case-insensitive comparisons: just add an "I" to the comparison operators. 
\begin{code}
\type{bit} False := \codestring{CASE} = \codestring{case}
\type{bit} True := \codestring{CASE} I= \codestring{case}\\

\type{bit} True := \codestring{CASE} < \codestring{case}
\type{bit} False := \codestring{CASE} i< \codestring{case} \commentline{"CASE" and "case" are case-insensitively \emph{equal}.}
\commentline{By the way, aptly, the "I" is case-insensitive.}\\

\commentline{Most of the time, the "i" just goes before the operator, but the comparer and not equals are a bit different.}
\type{bit} No := \codestring{CASE} !I= \codestring{case}
\type{bit} One For Equal := \codestring{CASE} <i=> \codestring{case} \commentline{The spaceship has an antenna.}
\end{code}

\indent There are more string-specific operators, too, for those little random string manipulation needs.
\begin{code}
\type{string} Big Ben := \codestring{big ben} \common{capitalized} \commentline{"Big Ben"}
\type{string} Screaming Loudly := \codestring{bwaaaaaaaa} \common{fully capitalized} \commentline{"BWAAAAAAAA"}
\type{string} Words := \codestring{I like big hats.} \common{split} \commentline{"I", "like", "big", and "hats."}
\commentline{Note that all lists have a split operator, but with strings, it defaults to groups of spaces, i.e. /"\textbackslash{}s+"/ (see Section \ref{par:Regex}).}
\end{code}

\indent Note that \English{} \type{strings} aren't generally null-terminated like in C. If you're using C stuff, be careful about that.

\sssecl{Special List Types}
\indent Here's an incredibly powerful tool that you won't find in almost any other programming language: you can specify the size of the list as part of the type! As we'll explain more later on in Section \ref{ssec:Types}, types can come with any kinds of properties: not just other types like Java or C++, but numbers, strings, or whatever else you can think of!
\begin{code}
3 \type{strings} Three Words For You := \codestring{I}, \codestring{hate}, and \codestring{you}	\commentline{"I", "hate", and "you"}
Three Words For You[1] := \codestring{love}	\commentline{"I", "love", and "you"}
Three Words For You := \codestring{I} and \codestring{love}	\commentline{ERROR! There are only two strings in this array!}
\end{code}

\indent There are a million uses for that one.
\indent There are times when you want to make a data structure with lots of dimensions, e.g. a four-dimensional matrix (for all you crazy math people out there)\ldots{}but who would want to write out "\type{list of lists of lists of lists of numbers}"? Thankfully, you don't have to!
\begin{code}
4-D \type{list of numbers} Hyperdimensional List := \common{a new} 4-D \type{list of numbers}
Hyperdimensional Matrix += 0	\commentline{[[[[0]]]]}
Hyperdimensional Matrix += (0, 5, and 9) and 12	\commentline{[[[[0], [0, 5, 9], [12]]]], a.k.a. 0, (0, 5, and 9), and 12}
\end{code}

\indent Much of \English{} is about clarity not just in writing, but in assumptions. In most programming languages, if you want to do some operations on a list of sorted things, you have to hope that the list given to you for the operation is sorted. In \English{}, we can use the advanced type system to guarantee it.
\indent The two special kinds of lists available to help us to that are called "\type{sorted}" and \type{sorting}". Sorted lists are lists that have been sorted once, e.g. by a run through a quick sort algorithm. Sorting lists are lists that constantly sort themselves as new elements are added to or removed from them. This means that adding things to a sorted list will make it unsorted again while sorting lists will keep sorting.
\begin{code}
\type{sorted strings} Sorted Names := \common{quicksort} \codestring{Abby}, \codestring{Doug}, \codestring{Britney}, \common{and} \codestring{Caroline}
Sorted Names -= \codestring{Abby} \commentline{This is fine; removing elements doesn't affect the order of the remaining ones!}
Sorted Names += \codestring{Eve} \commentline{ERROR! Even though it would technically still be in order, you're adding an item to a sort\emph{ed} list; this makes it unsorted, but you're also trying to put it back into Sorted Names, which can only contain sorted strings.}\\

\type{sorting ints} Tree := \common{a new} \type{binary search tree of ints} \common{with} 5, 9, 8, \common{and} -2 \commentline{B.S.T.s sort themselves; the elements we're putting into it aren't sorted, but they'll be sorted into the tree.}
Tree += 5 \commentline{This 5 will be sorted into the tree because B.S.T.s are a type of sort\emph{ing} list.}
\end{code}

\ssecl{Code Blocks}
\indent Nearly every language has some way to group operations together. Maybe you need to do three different things if something is true, for example. There are plenty of ways to delimit blocks; many language stick with the C-like curly braces ("\texttt{\{\}}"), but \English{} goes a different route. Like Python, in \English{}, indentation matters! To group operators together, you have to make sure that they all have the same indentation as either tabs or groups of four spaces. Blocks with something like an "if" statement, then there might be a comma, then your indented operators.
\sssecl{If and Its Friends}
\paragraph{If}
\indent Let's start with the simplest example of a code block: "\common{if}"! As you would expect whether you're familiar with other programming languages or not, you write the word "if", then some kind of condition that can either be true or false, then you put a comma and put the operators that you want to execute.
\begin{code}
\common{if} 5 < 3,
\qquad{}\commentline{The content below isn't really important; it's just showing how to indent.}
\qquad{}Variable++
\qquad{}State -= \codestring{15}
Variable\verb+--+ \commentline{This operation is NOT part of the if statement! It will be executed even if 5 < 3 is false!}
\end{code}

\paragraph{Switch-Case}
\indent \English{} also has "\common{switch}-\common{case}" statements. The basic versions of switch cases let you put one thing at the top; then, you can list cases and the program will execute at the case that matches the thing you put in the top. Also note that switch-case statements use colons instead of commas to start blocks. Here is an example:
\begin{code}
\common{switch by} Number: \commentline{\English{} adds the word "by" for readability.}
\common{case} 0:
\qquad\commentline{Do stuff if Number = 0.}
\qquad{}Number -= 5
\common{case} 1:
\qquad\commentline{Do stuff if Number = 1.}
\qquad{}Number++
\common{case} Another Number:
\qquad\commentline{Do stuff if Number = Another Number.}
\qquad\commentline{Yes, you can use other operators like variables for these cases, too.}
\qquad{}Number := Another Number
\common{case} 5:
\qquad\commentline{Do stuff if Number = 5.}
\qquad\commentline{\ldots{}BUT keep in mind that the case above might get it instead if Another Number was 5.}
\qquad{}Another Number\verb+--+
\common{default}:
\qquad\commentline{Do stuff if all the previous cases did not match; this is basically the 'else' of switch-cases.}
\qquad{}Number += 59
\end{code}

\indent Now, \English{} switch-case statements are much more versatile than ones you've seen in other languages. Sadly, the coolest stuff takes knowledge of high-order and partially applicable functionality (Sections \ref{ssec:High Order Functionality} and \ref{sssec:Missing Something? Partially Applied Operators}), but I'll tell you all about the fallthrough stuff now.
\indent Switch fallthrough is a behavior that determines when the program progresses to the next case in a switch-case statement if it doesn't reach a "\common{break}" statement. If you've seen other programming languages, you know they handle switch fallthrough differently. If the switch-case above was planted in C, it would actually act differently; in C, switch fallthrough always happens, so if Number was 0, it would do everything in case 0, then everything in case 1, then keep going all the way through. In \English{}, in the average switch-case like the one above, there is no switch fallthrough unless you have no operations in a case. (This is the way C\# does it.) Here's a more thorough example of your average everyday \English{} switch-case statement.
\begin{code}
\common{switch by} Number:
\common{case} 0:
\qquad\commentline{Do stuff if Number = 0.}
\qquad{}Number -= 5
\common{case} 1:
\qquad\commentline{Do stuff if Number = 1.}
\qquad\commentline{There are no operations in this 'case 1' section. (Comments don't count.)}
\qquad\commentline{Therefore, if Number is 1, it will fall through into 'case Another Number' below.}
\common{case} Another Number:
\qquad\commentline{Do stuff if Number = Another Number OR if Number = 1. (See above.)}
\qquad{}Number := Another Number
\common{case} 5:
\qquad\commentline{Do stuff if Number = 5 AND Number != Another Number.}
\common{default}:
\qquad\commentline{Do stuff if all the previous cases did not match.}
\qquad{}Number += 59
\end{code}
\sssecl{Loops}
\indent We have some really great loops. I think you'll enjoy them.
\indent We will start with the simplest; \common{while} loops work as you would expect the same way they do in any other language:
\begin{code}
\type{int} x := 8 \commentline{x is 8}
\common{while} x > 0,
\qquad{}x\verb+--+
\commentline{x is 0}
\end{code}

\indent There are also \common{do}-\common{while} loops:
\begin{code}
\type{int} x := 0
\common{do}
\qquad{}x\verb+--+
\common{while} x < 0
\commentline{Now x is -1.}
\end{code}

\indent "\common{while true}" is kind of ugly, but sometimes necessary, so we made it a bit cleaner:
\begin{code}
\common{forever,}
\qquad{}\commentline{do something forever}
\end{code}

\indent We have \common{for} loops, too, but our \common{for} loops are more exotic. This kind of \common{for} loop below is most closely related to the one you've seen before.
\begin{code}
\common{from} i := 0 \common{until} i < 5 \common{by} i++,
\qquad{}List[i]++\\

\commentline{The "from" and "by" sections are optional; imagine if i is already declared earlier.}
\common{until} i < 5 \common{by} i += 2,
	
\end{code}

\indent However, most of the time when using \English{}, you shouldn't have to use this. We have a couple of much cleaner \emph{and more efficient} loops that fit the most common situations:
\begin{code}
\type{strings} Strings := \codestring{red}, \codestring{blue}, \common{and} \codestring{green}
\common{for each} String \common{in} Strings,
\qquad{}String += \codechar{'s'}
\commentline{Strings is now "reds", "blues", and "greens"}\\

\type{int} Sum From 0 To 9 := 0
\common{from} i := 0 \common{to} 10, \commentline{Note that this does NOT include 10!}
\qquad{}Sum From 0 To 9 += i
\commentline{Sum From 0 To 9 is now 45.}\\

\type{bytes} Ten Zeroes := \common{a new} \type{list}
10 \common{times},
\qquad{}Ten Zeroes += 0
\commentline{Now Ten Zeroes has 10 zeroes}
\commentline{This can also be written as "do (Ten Zeroes += 0) 10 times" (parentheses optional, but advised)}
\end{code}

\ssecl{Operators}
\indent Operators are the core of the language. Everything -- \emph{everything} -- in \English is an operator. No, I don't just mean the \texttt{+} and I don't just mean stuff like "\common{a new list}"; I mean numbers, strings, loops, if statements, and even the operator to define new operators that will be described in the next paragraph.

\indent The operator to define a new operator is one of the few operators built into the language (for obvious reasons). It starts with the word "\keyop{define}". Then, you can use op modifiers (see Section \ref{ssec:Op Modifiers}); don't be concerned about those now. Then, add a return type for the operator delineated by angle brackets ("\texttt{<>}"). Then, we have the operator declaration itself, which ends with a colon ("\texttt{:}"), then all the operators that describe what the new operator should do (like the body of a function).
\indent Let us begin with the most simple example: an one-word operator with no arguments. Let us imagine an operator called "\texttt{sixteen}" that gives\ldots well, yeah, 16.
\begin{code}
\keyop{define} \defpunct{<}\type{byte}\defpunct{>} sixteen\defpunct{:}
\qquad{}16
\end{code}

\indent To use this operator, just write "sixteen":
\begin{code}
\type{int} Number := sixteen \commentline{Number now contains 16.}
\end{code}

\indent Now it gets interesting: we'll define an operator with an argument. This operator starts with the word "\texttt{double}", then takes a number; it will add the number it captures to itself (essentially doubing it) and return the result. Note that in \English{}, the last operator in an operator declaration gives the return value; there is no "return" keyword like in other languages.
\begin{code}
\keyop{define} \defpunct{<}\type{number}\defpunct{>} double \preprocess{<}\type{number} Number\preprocess{>}\defpunct{:}
\qquad{}Number + Number
\end{code}

\indent Here is an example of how you might use the operator we just defined above. Note that we use an \type{int} here rather than a \type{number}, but an \type{int} is a type of \type{number}, so it works.
\begin{code}
\type{int} Integer := 2
Integer := double Integer \commentline{Integer is now 4.}
\end{code}

\indent The operator declaration syntax is very special; not only can you designate arguments, but you can use many of the basic regex operators found in other languages. For example, the "\preprocess{|}" is a regex "or"; it allows you to match multiple different things with one operator. For example, 

% TODO: example

\ssecl{Op Modifiers}
\sssecl{Definining Them}
\paragraph{Using Them}
\ssecl{Types}
\paragraph{Defining Them}

\paragraph{Using Them}

\sssecl{Type Modifiers}
\paragraph{Defining Them}

\paragraph{Using Them}

\sssecl{Matchers}
\paragraph{Regex} \label{par:Regex}

\sssecl{Units}
\paragraph{Defining Them}

\paragraph{Using Them}

\ssecl{Errors}
\paragraph{Defining Them}

\paragraph{Using Them}

\ssecl{Streams}
\ssecl{Input and Output}
\sssecl{Stdin Reading and Stdout Printing}

\sssecl{File Reading and Writing}

\ssecl{Implicit Conversion}
\sssecl{What?}

\sssecl{Why?}

\sssecl{Super-implicit?}

\ssecl{High Order Functionality}
\sssecl{What?}

\sssecl{Why?}

\sssecl{Missing Something? Partially Applied Operators}

\sssecl{Operator Modifiers}

\sssecl{Scope and Contextual Operators}

\secl{The Basis of the Language}
\ssecl{\texttt{\textbf{operator}}}

\ssecl{\texttt{\textbf{define}}}

\ssecl{\texttt{\textbf{asm}}}

\ssecl{\texttt{\textbf{run}}}

\ssecl{\texttt{\textbf{bits}}}

\ssecl{\texttt{\textbf{use}}}

\ssecl{\texttt{\textbf{err on}}}
\ssecl{\texttt{\textbf{warn about}}}
\secl{The Not-So-Complicated Compilation}
\ssecl{Idea}

\ssecl{Optimizability}
\end{document}
